// Top-level document rule
Document = { SOI ~ Statement* ~ EOI }

// Top-level statements
Statement     = ${ DocComment* ~ WHITESPACE* ~ StatementKind }
StatementKind = !{ ImportStatement | TypeStatement | LetStatement | ExportStatement }

// Import statement
ImportStatement = ${ ImportKeyword ~ DelimitingSpace+ ~ Ident ~ (DelimitingSpace+ ~ WithClause)? ~ DelimitingSpace* ~ Colon ~ DelimitingSpace* ~ ImportType ~ DelimitingSpace* ~ Semicolon }
WithClause      = ${ WithKeyword ~ DelimitingSpace+ ~ String }
ImportType      = !{ PackagePath | FuncType | InlineInterface | Ident }
PackagePath     = ${ PackageName ~ (Slash ~ Ident)* ~ (At ~ PackageVersion)? }
PackageName     = ${ Ident ~ (":" ~ Ident)+ }
PackageVersion  =  { (ASCII_ALPHANUMERIC | "." | "-" | "+")+ }

// Type statement
TypeStatement            = !{ InterfaceDecl | WorldDecl | ValueTypeStatement }
ValueTypeStatement       =  { ResourceDecl | VariantDecl | RecordDecl | FlagsDecl | EnumDecl | TypeAlias }
ResourceDecl             = ${ ResourceKeyword ~ DelimitingSpace+ ~ Ident ~ DelimitingSpace* ~ ResourceBody }
ResourceBody             = !{ Semicolon | (OpenBrace ~ (ResourceMethod ~ Semicolon)+ ~ CloseBrace) }
VariantDecl              = ${ VariantKeyword ~ DelimitingSpace+ ~ Ident ~ DelimitingSpace* ~ VariantBody }
VariantBody              = !{ OpenBrace ~ VariantCase ~ ("," ~ VariantCase)* ~ ","? ~ CloseBrace }
VariantCase              =  { Ident ~ VariantType? }
VariantType              =  { OpenParen ~ Type ~ CloseParen }
RecordDecl               = ${ RecordKeyword ~ DelimitingSpace+ ~ Ident ~ DelimitingSpace* ~ RecordBody }
RecordBody               = !{ OpenBrace ~ NamedType ~ ("," ~ NamedType)* ~ ","? ~ CloseBrace }
FlagsDecl                = ${ FlagsKeyword ~ DelimitingSpace+ ~ Ident ~ DelimitingSpace* ~ FlagsBody }
FlagsBody                = !{ OpenBrace ~ Ident ~ ("," ~ Ident)* ~ ","? ~ CloseBrace }
EnumDecl                 = ${ EnumKeyword ~ DelimitingSpace+ ~ Ident ~ DelimitingSpace* ~ EnumBody }
EnumBody                 = !{ OpenBrace ~ Ident ~ ("," ~ Ident)* ~ ","? ~ CloseBrace }
TypeAlias                = ${ TypeKeyword ~ DelimitingSpace+ ~ Ident ~ DelimitingSpace* ~ Equals ~ DelimitingSpace* ~ TypeAliasKind ~ DelimitingSpace* ~ Semicolon }
TypeAliasKind            = !{ FuncType | Type }
ResourceMethod           =  { Constructor | Method }
Constructor              =  { ConstructorKeyword ~ ParamList }
Method                   =  { Ident ~ Colon ~ StaticKeyword? ~ FuncTypeRef }
FuncTypeRef              =  { Ident | FuncType }
FuncType                 =  { FuncKeyword ~ ParamList ~ ResultList? }
ParamList                =  { OpenParen ~ (NamedType ~ ("," ~ NamedType)* ~ ","?)? ~ CloseParen }
ResultList               =  { Arrow ~ (NamedResultList | Type) }
NamedResultList          =  { OpenParen ~ (NamedType ~ ("," ~ NamedType)* ~ ","?)? ~ CloseParen }
NamedType                =  { Ident ~ Colon ~ Type }
Type                     =  {
    U8Keyword
  | S8Keyword
  | U16Keyword
  | S16Keyword
  | U32Keyword
  | S32Keyword
  | U64Keyword
  | S64Keyword
  | Float32Keyword
  | Float64Keyword
  | CharKeyword
  | BoolKeyword
  | StringKeyword
  | Tuple
  | List
  | Option
  | Result
  | Borrow
  | Ident
}
Tuple                    =  { TupleKeyword ~ OpenAngle ~ Type ~ ("," ~ Type)* ~ CloseAngle }
List                     =  { ListKeyword ~ OpenAngle ~ Type ~ CloseAngle }
Option                   =  { OptionKeyword ~ OpenAngle ~ Type ~ CloseAngle }
Result                   =  { ResultKeyword ~ SpecifiedResult? }
SpecifiedResult          =  { OpenAngle ~ OmitType ~ ("," ~ Type)? ~ CloseAngle }
OmitType                 =  { Underscore | Type }
Borrow                   =  { BorrowKeyword ~ OpenAngle ~ Ident ~ CloseAngle }
InterfaceDecl            = ${ InterfaceKeyword ~ DelimitingSpace+ ~ Ident ~ DelimitingSpace* ~ InterfaceBody }
InterfaceBody            = !{ OpenBrace ~ InterfaceItem* ~ CloseBrace }
InterfaceItem            = ${ DocComment* ~ WHITESPACE* ~ InterfaceItemKind }
InterfaceItemKind        = !{ UseStatement | ValueTypeStatement | InterfaceExportStatement }
InterfaceExportStatement =  { Ident ~ Colon ~ FuncTypeRef ~ Semicolon }
// TODO: support world include statements
WorldDecl            = ${ WorldKeyword ~ DelimitingSpace+ ~ Ident ~ DelimitingSpace* ~ WorldBody }
WorldBody            = !{ OpenBrace ~ WorldItem* ~ CloseBrace }
WorldItem            = ${ DocComment* ~ WHITESPACE* ~ WorldItemKind }
WorldItemKind        = !{ UseStatement | ValueTypeStatement | WorldImportStatement | WorldExportStatement }
WorldImportStatement = ${ ImportKeyword ~ DelimitingSpace+ ~ WorldItemDecl ~ DelimitingSpace* ~ Semicolon }
WorldExportStatement = ${ ExportKeyword ~ DelimitingSpace+ ~ WorldItemDecl ~ DelimitingSpace* ~ Semicolon }
WorldItemDecl        = !{ WorldNamedItem | InterfaceRef }
WorldNamedItem       = ${ Ident ~ DelimitingSpace* ~ Colon ~ DelimitingSpace+ ~ ExternType }
InterfaceRef         =  { PackagePath | Ident }
ExternType           = !{ FuncType | InlineInterface | Ident }
InlineInterface      =  { InterfaceKeyword ~ InterfaceBody }

// Let statement
LetStatement = ${ LetKeyword ~ DelimitingSpace+ ~ Ident ~ DelimitingSpace* ~ Equals ~ DelimitingSpace* ~ Expr ~ DelimitingSpace* ~ Semicolon }

// Export statement
ExportStatement = ${ ExportKeyword ~ DelimitingSpace+ ~ Expr ~ DelimitingSpace* ~ WithClause? ~ DelimitingSpace* ~ Semicolon }

// Expressions
// Note: currently there are only two operators (postfix . and postfix []),
// and both have the same precedence, so no climbing is needed.
Expr                       = !{ PrimaryExpr ~ PostfixExpr* }
PrimaryExpr                =  { NewExpr | NestedExpr | Ident }
NewExpr                    = ${ NewKeyword ~ DelimitingSpace+ ~ PackageName ~ DelimitingSpace* ~ NewExprBody }
NewExprBody                = !{ OpenBrace ~ (InstantiationArgument ~ ("," ~ InstantiationArgument)* ~ ","?)? ~ Ellipsis? ~ CloseBrace }
InstantiationArgument      =  { NamedInstantiationArgument | Ident }
NamedInstantiationArgument =  { Ident ~ Colon ~ Expr }
NestedExpr                 =  { OpenParen ~ Expr ~ CloseParen }
PostfixExpr                =  { AccessExpr | NamedAccessExpr }
AccessExpr                 = ${ Dot ~ Ident }
NamedAccessExpr            =  { OpenBracket ~ String ~ CloseBracket }

// Use statement in interface and world definitinos
UseStatement = ${ UseKeyword ~ DelimitingSpace+ ~ UseItems ~ DelimitingSpace* ~ Semicolon }
UseItems     = !{ UsePath ~ Dot ~ OpenBrace ~ Ident ~ ("," ~ Ident)* ~ ","? ~ CloseBrace }
UsePath      =  { PackagePath | Ident }

// Identifiers
RawIdent  = _{ Percent ~ IdentPart ~ (Hyphen ~ IdentPart)* }
Ident     = @{ RawIdent | !Keyword ~ IdentPart ~ (Hyphen ~ IdentPart)* }
IdentPart = @{ ASCII_ALPHA_LOWER ~ (ASCII_ALPHA_LOWER | ASCII_DIGIT)* }

// Strings
String = @{ DoubleQuote ~ (!DoubleQuote ~ ANY)* ~ DoubleQuote }

// Keywords
ImportKeyword      =  { "import" }
WithKeyword        =  { "with" }
TypeKeyword        =  { "type" }
TupleKeyword       =  { "tuple" }
ListKeyword        =  { "list" }
OptionKeyword      =  { "option" }
ResultKeyword      =  { "result" }
BorrowKeyword      =  { "borrow" }
ResourceKeyword    =  { "resource" }
VariantKeyword     =  { "variant" }
RecordKeyword      =  { "record" }
FlagsKeyword       =  { "flags" }
EnumKeyword        =  { "enum" }
FuncKeyword        =  { "func" }
StaticKeyword      =  { "static" }
ConstructorKeyword =  { "constructor" }
U8Keyword          =  { "u8" }
S8Keyword          =  { "s8" }
U16Keyword         =  { "u16" }
S16Keyword         =  { "s16" }
U32Keyword         =  { "u32" }
S32Keyword         =  { "s32" }
U64Keyword         =  { "u64" }
S64Keyword         =  { "s64" }
Float32Keyword     =  { "float32" }
Float64Keyword     =  { "float64" }
CharKeyword        =  { "char" }
BoolKeyword        =  { "bool" }
StringKeyword      =  { "string" }
InterfaceKeyword   =  { "interface" }
WorldKeyword       =  { "world" }
ExportKeyword      =  { "export" }
NewKeyword         =  { "new" }
LetKeyword         =  { "let" }
UseKeyword         =  { "use" }
Keyword            = _{
    ImportKeyword
  | WithKeyword
  | TypeKeyword
  | TupleKeyword
  | ListKeyword
  | OptionKeyword
  | ResultKeyword
  | BorrowKeyword
  | ResourceKeyword
  | VariantKeyword
  | RecordKeyword
  | FlagsKeyword
  | EnumKeyword
  | FuncKeyword
  | StaticKeyword
  | ConstructorKeyword
  | U8Keyword
  | S8Keyword
  | U16Keyword
  | S16Keyword
  | U32Keyword
  | S32Keyword
  | U64Keyword
  | S64Keyword
  | Float32Keyword
  | Float64Keyword
  | CharKeyword
  | BoolKeyword
  | StringKeyword
  | InterfaceKeyword
  | WorldKeyword
  | ExportKeyword
  | NewKeyword
  | LetKeyword
  | UseKeyword
}

// Comments
DocComment   = ${ (" " | "\t")* ~ (("///" ~ (!NEWLINE ~ ANY)* ~ NEWLINE) | ("/**" ~ (!"*/" ~ ANY)* ~ "*/" ~ NEWLINE)) }
LineComment  = _{ ("//" ~ !"/" ~ (!NEWLINE ~ ANY)*) }
BlockComment = _{ "/**/" | "/*" ~ !"*" ~ (BlockComment | !"*/" ~ ANY)* ~ "*/" }

// Symbols
// These exist to for explicit matching, which assists in error reporting
Semicolon    = { ";" }
OpenBrace    = { "{" }
CloseBrace   = { "}" }
Colon        = { ":" }
Equals       = { "=" }
OpenParen    = { "(" }
CloseParen   = { ")" }
Arrow        = { "->" }
OpenAngle    = { "<" }
CloseAngle   = { ">" }
Percent      = { "%" }
Underscore   = { "_" }
Hyphen       = { "-" }
DoubleQuote  = { "\"" }
Slash        = { "/" }
At           = { "@" }
OpenBracket  = { "[" }
CloseBracket = { "]" }
Dot          = { "." }
Ellipsis     = { "..." }

// Special values inserted at every sequence (for non-atomic rules)
WHITESPACE = _{ " " | "\t" | NEWLINE }
COMMENT    = _{ LineComment | BlockComment }

// Used to delimit certain tokens
DelimitingSpace = _{ WHITESPACE | COMMENT }
